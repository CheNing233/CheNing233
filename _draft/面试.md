# 个人介绍

面试官您好，我叫*，现在大三。目前在校团队担任前端开发工程师，主导推进团队项目WA-AI绘图平台，这个项目是我自己不断摸索学习搭建起来的，现在在团队内主要负责前端界面开发以及后端AI算力服务的开发设计和对接，做过大文件上传、性能优化、虚拟列表和canvas图片编辑器这些，最近正在做将开源的comfyui工作流项目通过微前端架构整合进来的工作。

## 大文件上传

### 背景

AI应用，用户自定义大模型的上传，一般这种模型都是4G以上，像SDXL这种上到了10个G的也有

这种大模型上传，如果碰到断连了，之前上传的进度丢失了，就很难受，并且我这个项目，前端是挂在新加坡那边的，虽说能直连，但这种丢失进度的沉没成本是非常大的

所以我就找到并学习了这种分片上传的技术，首先前端进行模型文件的SHA256计算，拿到这个模型的特征，唯一标识，然后向后端请求这个文件是不是上传了，上传了多少，如果没上传，那就从0开始，如果上传了一半，那就接着上传，如果合并失败，那就把缺失的分片补传

### 优化

- 切片和计算sha256的工作交给web-worker建立多线程来完成
- 完善这个类，做成可复用的

## 虚拟列表

主要原理是如果元素在可显示的范围当中就渲染，如果不在就不渲染，减少DOM的数量来减轻浏览器的压力

## 性能优化

- 虚拟列表减少DOM的数量，减轻浏览器渲染压力
- 使用loadable库，将一些组件分包加载，而不是一次性加载，加快首屏加载速度
- 前端、图片服务器在国外，图片加载速度过慢，采用先加载低分辨率的模糊图进行占位，再加载高清图进行替换
- 将一些大文件，比如openpose手部模型，直接设计为静态资源，不进行webpack打包，按需请求

## Canvas图片编辑器

正常图片的编辑：用了两层canvas，顶层canvas用来绘制线条，底层canvas用来显示图片，放大缩小控制两个canvas进行同时放大缩小，保存时控制顶层canvas将线条与底层的合并，实现输出修改后的图片，并且保留了原图以及可以撤销重做的能力

蒙版编辑：用了三层canvas，顶层canvas一样是绘制线条，中层canvas用来填充黑色，底层的负责显示背景图，输出蒙版时将顶层和中间层合并，输出蒙版控制图片，并且能做到是参照原图进行涂抹的

## 微前端架构

探讨过wujie、qiankun、single-spa、iframe这些，起初是用wujie，但是碰到了样式丢失的问题，并且我在找他的issue的时候，发现他这个大致原理是先建立一个iframe用来渲染主应用，用来获取主应用的一些location啊这些路由信息，然后立即终止主应用渲染，注入子应用，通过这个方法就可以让子应用使用主应用的一些路由什么的，然后避免出现跨域错误这些，但他这个实现是通过轮询实现的，非常不稳定，轮询实现就意味着你电脑性能好，就报错，因为主应用的js污染子应用了，性能不好就不报错，所以我就抛弃了这个方案

## 人生首面

1. 盒子模型
2. 标准盒子和怪异盒子
3. display的各种东西
4. css实现左右两列
5. 原型链
6. vue
7. JavaScript原生实现拖拽

花俩天晚上背八股，只能说10分钟就挂了。
