## 原型链定义

JS 的一切引用数据类型（基本数据类型不是）皆对象，对象就是属性和方法的集合，原型和原型链是为对象操作而服务的

原型的目的是组成原型链

原型链是设计来让一个对象继承另一个对象的属性和方法而设计的，即`方便对象之间属性共享`

共享对象方法的好处就是可以进行代码复用，也可以对单独的对象进行代码拓展，俗称面向对象

## 对象的属性和方法

一般来说，属性是每个对象实例独有的，而方法（逻辑）是需要做到共享复用的

​**​属性与方法的分离原则​**​

- ​**​实例属性​**​：用于存储对象状态（如用户数据），需保持独立性。
- ​**​原型方法​**​：用于定义行为逻辑（如计算、交互），需保持复用性

## 创建一个对象

- 通过 new 操作符跟随一个函数，这个函数就叫构造函数
- 通过字面量书写

```js
// new操作符后跟函数调用
let obj = new Object()
let arr = new Array()

// 字面量表示法
let obj = { a: 1}
// 等同于
let obj = new Object()
obj.a = 1

let arr = [1,2]
// 等同于
let arr = new Array()
arr[0] = 1
arr[1] = 2
```

## 构造函数

构造函数跟普通函数一样，但被一般用来生产对象

构造函数生产对象，用的模板就是构造函数的`原型`

每次在构造函数生产对象实例时，总会设置对象的`__proto__`指向自己的模板，也就是构造函数的`原型`

### 翻译

原型 prototype 就是 `模板`、`初号对象`

对象的 proto 属性 指向 `生产它的模板`

原型本来就含有模板、初号机对象的意思

## 原型链连接图

![image.png](https://img.glcn.top//piclist/1733951520126-72a3642b5fdb4da4b2d67df7c25d5b9b.png)

一个对象含有\_\_proto\_\_属性，这个指向其构造函数的原型

```js
person.__proto__ === Person.prototype
```

原型也是个对象，所以也有\_\_proto\_\_，这个就指向更上一级的原型

```js
Person.prototype.__proto__ === Object.prototype
```

所以按上图看得出来，原型链就是原型 prototype 用 \_\_proto\_\_ 属性串起来的链条

~~万物起原~~，那么一切引用数据类型皆对象

最顶层的原型就是 Object.prototype 了，再往上就是 null

### constructor 属性

只有原型对象有，一般的对象没有，指向构造函数

因为构造函数就挂着原型对象，所以 XXX.prototype.constructor === XXX

相当于方向相反的引用

```js
// 构造函数找原型
XXX.prototype === XObj
// 原型找构造函数
XObj.constructor === XXX
```

### 注意点

是对象就有 \_\_proto\_\_ 指向原型

只有函数有 prototype，也就是原型，任何函数都可以是构造函数

## 原型链查找方法

首先找自己（对象）有没有这个属性或者方法

没有，就顺着 \_\_proto\_\_ 往上找原型，也就是`构造函数.prototype`

首先都是找到构建自己的构造函数的原型

检查原型里头有没有这个属性或方法

没有，继续顺着 \_\_proto\_\_ 往上找原型

直到找到 Object.prototype

如果 Object.prototype 还是没有，那么属性就返回 undefined，方法就抛出报错

### 遮蔽效应

若对象自身或低级原型中存在同名属性，高层级原型的属性会被忽略。

也就是先找自己身上有没有，再找低层级原型上有没有，就近原则

因为逐级向上找，找到了就立即返回，就会遮蔽高层级原型上定义的同名属性或方法

## 函数对象

函数也是对象

比如随便一个函数 fn，它的原型就是`Function.prototype`

Function也是对象，但它的原型还是指向`Function.prototype`
