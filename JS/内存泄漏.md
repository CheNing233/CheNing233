由于设计错误，应用程序在分配某段内存后，导致在释放这段内存之前就失去了对这段内存的控制

## GC（Garbage Collecation）

Javascript 具有自动垃圾回收机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存

### 标记-清除算法

大部分浏览器都支持和使用，

- 标记阶段：垃圾回收器会从根（roots）开始，递归地访问对象的属性。根通常是全局对象（在浏览器中是 window 对象）或者执行上下文中的局部变量。访问过的对象都会被标记为“活动”或“可达”，表示这些对象仍在被使用。  
- 清除阶段：在标记阶段完成后，垃圾回收器会遍历堆中的所有对象。任何未被标记为“活动”或“可达”的对象都将被视为垃圾，它们的内存空间会被释放，以便将来分配给新对象。

总的来说，就是从根开始递归访问对象的属性，将能访问的对象标记为“活动”的，不可访问的标记为“不可达”的，然后在清理阶段将“不可达”的对象清除

问题：会导致内存碎片问题，然后出现了一种改进算法：`标记-整理`，这种算法在标记阶段和标记-清除算法差不多，但在标记完毕后，将活的对象向内存一端移动，清理掉边界的内存。

### 引用计数方法（不建议使用）

引用计数的策略就是跟踪每一个变量被引用的次数，当引用计数变为0时，则可以视为没有任何对象引用他了，就可以被清除

问题：对于循环引用，obj1和obj2互相引用，那二者的引用计数永远不可能为0，导致内存泄漏

### NodeJs V8 的分代式算法

#### 新生代和老生代

新生代，指的是新产生的对象；老生代就是经历过新生代垃圾回收后还“存活”下来的对象。

#### 新生代：Scavenge 算法

一个处于使用状态的空间叫 From 空间，一个处于闲置状态的空间称为 To 空间

![image.png](https://img.glcn.top//piclist/1734641623468-29db2d1110834a4a89d71ff1b4b3fed8.png)

当开始进行垃圾回收时，首先会检查From里存活的对象，将其移动到To区。然后将From区清除，保留To区存活的对象。最后二者身份互换，也就是From区变To区，To区变From区。

就是通过上述算法来回移动对象进行垃圾清理

#### 老生代：标记-清除

在新生代区移动多次仍然存活的对象，将会移动到老生代区，使用新的方法进行管理

标记清除在标记阶段会标记活着的对象，而在内存回收阶段，它会清除没有被标记的对象。

### 停顿问题：增量标记法

前面的三种算法（标记-清除、引用计数、Sacavenge），都需要将正在执行的 JavaScript 应用逻辑暂停下来，待垃圾回收完毕后再恢复。这种行为叫作“全停顿”（stop-the-world）。

在 V8 新生代的分代回收中，只收集新生代，而新生代通常配置较小，且存活对象较少，所以全停顿的影响不大，而老生代就相反了。  （新生代对象少，影响不大，老生代影响大）

为了降低全部老生代全堆垃圾回收带来的停顿时间，V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和JS应用逻辑交替进行，直到标记阶段完成。（交替执行标记）

## 引起内存泄漏的常见场景

- 全局变量（this误用）
- 作用域未释放（闭包）
- 无效的DOM引用
- 定时器未清除
- 事件监听未清除

